from pydub import AudioSegment
from pydub.silence import split_on_silence
from moviepy.editor import VideoFileClip, concatenate_videoclips
import os
import multiprocessing

def process_segment(segment, text, index):
    # Render subtitles
    segment = segment.subclip(0, segment.duration-100)  # Adjust the duration as needed
    sub = segment.subtitles(text)
    sub.set_position(('center', 'bottom'))

    # Write segment to file
    output_path = f"segment_{index}.mp4"
    sub.write_videofile(output_path, codec="libx264", audio_codec="aac", temp_audiofile=f"temp_{index}.m4a", remove_temp=True)

    return output_path

def generate_subtitles(video_file, text_file, output_video):
    # Read text from the text file
    with open(text_file, 'r', encoding='utf-8') as f:
        text_lines = f.readlines()

    # Open the video file
    video = VideoFileClip(video_file)

    # Process audio from video
    audio = video.audio

    # Split audio into segments of silence
    segments = split_on_silence(audio, min_silence_len=500, silence_thresh=-40)

    # Define the number of parallel processes
    num_processes = min(multiprocessing.cpu_count(), len(segments))

    # Process segments in parallel
    with multiprocessing.Pool(processes=num_processes) as pool:
        results = [pool.apply_async(process_segment, args=(segment, text_lines[i % len(text_lines)], i)) for i, segment in enumerate(segments)]
        segment_paths = [result.get() for result in results]

    # Combine segments into a single video
    final_video = concatenate_videoclips([VideoFileClip(path) for path in segment_paths])
    final_video.write_videofile(output_video)

    # Clean up temporary files
    for path in segment_paths:
        os.remove(path)

if __name__ == "__main__":
    # Define input files and output directory
    video_file = "input_video.mp4"
    text_file = "input_text.txt"
    output_video = "output_video.mp4"

    # Generate subtitles
    generate_subtitles(video_file, text_file, output_video)
